<!DOCTYPE html><!DOCTYPE html><!DOCTYPE html>

<html lang="en">

<html lang="en"><html lang="en">

<head>

  <meta charset="UTF-8" />

  <title>MuJoCo Robot Viewer</title>

  <script type="importmap"><head><head>

    {

      "imports": {  <meta charset="UTF-8" />  <meta charset="UTF-8" />

        "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",

        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"  <title>MuJoCo Robot Viewer</title>  <title>MuJoCo Robot Viewer</title>

      }

    }  <script type="importmap">  <script type="importmap">

  </script>

</head>    {    {



<body>      "imports": {      "imports": {

  <script type="module">

    import * as THREE from 'three';        "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",        "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",

    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    import load_mujoco from './static/dist/mujoco_wasm.js';        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"

    import {

      loadSceneFromURL,      }      }

      getPosition,

      getQuaternion,    }    }

      standardNormal

    } from './static/dist/mujocoUtils.js';  </script>  </script>



    const mujoco = await load_mujoco();</head></head>



    // Set up FS directories

    mujoco.FS.mkdir('/working');

    mujoco.FS.mount(mujoco.MEMFS, { root: '.' }, '/working');<body><body>

    mujoco.FS.mkdir('/working/assets');

  <script type="module">  <script type="module">

    // Load XML model and meshes

    const xmlURL = './static/scene/kitchen/scene.xml';    import * as THREE from 'three';    import * as THREE from 'three';



    const meshFiles = [    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

'counter.png',

'drawer_600_full.obj',    import load_mujoco from './static/dist/mujoco_wasm.js';    import load_mujoco from './static/dist/mujoco_wasm.js';

'drawer_600_full.png',

'drawer_600_half.obj',    import {    import {

'drawer_600_half.png',

'drawer_600_quarter.obj',      loadSceneFromURL,      loadSceneFromURL,

'drawer_600_quarter.png',

'drawer_handle.obj',      getPosition,      getPosition,

'finger_0.obj',

'finger_1.obj',      getQuaternion,      getQuaternion,

'hand_0.obj',

'hand_1.obj',      standardNormal      standardNormal

'hand_2.obj',

'hand_3.obj',    } from './static/dist/mujocoUtils.js';    } from './static/dist/mujocoUtils.js';

'hand_4.obj',

'hand.stl',

'handle.png',

'hob.png',    const mujoco = await load_mujoco();    const mujoco = await load_mujoco();

'link0_0.obj',

'link0_1.obj',

'link0_10.obj',

'link0_11.obj',    // Set up FS directories    // Set up FS directories

'link0_2.obj',

'link0_3.obj',    mujoco.FS.mkdir('/working');    mujoco.FS.mkdir('/working');

'link0_4.obj',

'link0_5.obj',    mujoco.FS.mount(mujoco.MEMFS, { root: '.' }, '/working');    mujoco.FS.mount(mujoco.MEMFS, { root: '.' }, '/working');

'link0_7.obj',

'link0_8.obj',    mujoco.FS.mkdir('/working/assets');    mujoco.FS.mkdir('/working/assets');

'link0_9.obj',

'link0.stl',

'link1.obj',

'link1.stl',    // Load XML model and meshes    // Load XML model and meshes

'link2.obj',

'link2.stl',    const xmlURL = './static/scene/kitchen/scene.xml';    const xmlURL = './static/scene/kitchen/scene.xml';

'link3_0.obj',

'link3_1.obj',

'link3_2.obj',

'link3_3.obj',    const meshFiles = [    const meshFiles = [

'link3.stl',

'link4_0.obj','counter.png','counter.png',

'link4_1.obj',

'link4_2.obj','drawer_600_full.obj','drawer_600_full.obj',

'link4_3.obj',

'link4.stl','drawer_600_full.png','drawer_600_full.png',

'link5_0.obj',

'link5_1.obj','drawer_600_half.obj','drawer_600_half.obj',

'link5_2.obj',

'link5_collision_0.obj','drawer_600_half.png','drawer_600_half.png',

'link5_collision_1.obj',

'link5_collision_2.obj','drawer_600_quarter.obj','drawer_600_quarter.obj',

'link6_0.obj',

'link6_1.obj','drawer_600_quarter.png','drawer_600_quarter.png',

'link6_10.obj',

'link6_11.obj','drawer_handle.obj','drawer_handle.obj',

'link6_12.obj',

'link6_13.obj','finger_0.obj','finger_0.obj',

'link6_14.obj',

'link6_15.obj','finger_1.obj','finger_1.obj',

'link6_16.obj',

'link6_2.obj','hand_0.obj','hand_0.obj',

'link6_3.obj',

'link6_4.obj','hand_1.obj','hand_1.obj',

'link6_5.obj',

'link6_6.obj','hand_2.obj','hand_2.obj',

'link6_7.obj',

'link6_8.obj','hand_3.obj','hand_3.obj',

'link6_9.obj',

'link6.stl','hand_4.obj','hand_4.obj',

'link7_0.obj',

'link7_1.obj','hand.stl','hand.stl',

'link7_2.obj',

'link7_3.obj','handle.png','handle.png',

'link7_4.obj',

'link7_5.obj','hob.png','hob.png',

'link7_6.obj',

'link7_7.obj','link0_0.obj','link0_0.obj',

'link7.stl',

'wood_tray_collision_0.obj','link0_1.obj','link0_1.obj',

'wood_tray_collision_1.obj',

'wood_tray_collision_10.obj','link0_10.obj','link0_10.obj',

'wood_tray_collision_11.obj',

'wood_tray_collision_2.obj','link0_11.obj','link0_11.obj',

'wood_tray_collision_3.obj',

'wood_tray_collision_4.obj','link0_2.obj','link0_2.obj',

'wood_tray_collision_5.obj',

'wood_tray_collision_6.obj','link0_3.obj','link0_3.obj',

'wood_tray_collision_7.obj',

'wood_tray_collision_8.obj','link0_4.obj','link0_4.obj',

'wood_tray_collision_9.obj',

'wood_tray_diffuse.png','link0_5.obj','link0_5.obj',

'wood_tray.obj',

    ];'link0_7.obj','link0_7.obj',



'link0_8.obj','link0_8.obj',

    const xmlText = await (await fetch(xmlURL)).text();

    mujoco.FS.writeFile('/working/scene.xml', xmlText);'link0_9.obj','link0_9.obj',

    console.log(xmlText);

'link0.stl','link0.stl',

    for (const meshFile of meshFiles) {

      const res = await fetch(`./static/scene/kitchen/assets/${meshFile}`);'link1.obj','link1.obj',

      if (!res.ok) {

        console.error(`Failed to load ${meshFile}: ${res.statusText}`);'link1.stl','link1.stl',

        continue;

      }'link2.obj','link2.obj',

      const buf = await res.arrayBuffer();

      mujoco.FS.writeFile(`/working/assets/${meshFile}`, new Uint8Array(buf));'link2.stl','link2.stl',

    }

'link3_0.obj','link3_0.obj',

    async function loadData() {

      const response = await fetch('./static/data/LiftTrayEnv_BimanualPanda_2025-04-21_20-00-24.json');'link3_1.obj','link3_1.obj',

      const data = await response.json();

      return data["proprioception"];'link3_2.obj','link3_2.obj',

    }

    const data = await loadData();'link3_3.obj','link3_3.obj',



    // THREE.js Scene Setup'link3.stl','link3.stl',

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);'link4_0.obj','link4_0.obj',



    const renderer = new THREE.WebGLRenderer({ antialias: true });'link4_1.obj','link4_1.obj',

    renderer.setSize(window.innerWidth, window.innerHeight);

    document.body.appendChild(renderer.domElement);'link4_2.obj','link4_2.obj',



    const controls = new OrbitControls(camera, renderer.domElement);'link4_3.obj','link4_3.obj',

    controls.enableDamping = true;

'link4.stl','link4.stl',

    scene.add(new THREE.AmbientLight(0x404040));

    const light = new THREE.DirectionalLight(0xffffff, 1);'link5_0.obj','link5_0.obj',

    light.position.set(4, 4, 4);

    scene.add(light);'link5_1.obj','link5_1.obj',



    let i = 0;'link5_2.obj','link5_2.obj',



    const parent = {'link5_collision_0.obj','link5_collision_0.obj',

      scene: scene,

      camera: camera,'link5_collision_1.obj','link5_collision_1.obj',

      controls: controls,

      model: {},'link5_collision_2.obj','link5_collision_2.obj',

      state: {},

      simulation: {}'link6_0.obj','link6_0.obj',

    };

'link6_1.obj','link6_1.obj',



    var bodies = {};'link6_10.obj','link6_10.obj',

    var lights = {};

    let model = parent.model;'link6_11.obj','link6_11.obj',

    let state = parent.state;

    let simulation = parent.simulation;'link6_12.obj','link6_12.obj',



    'link6_13.obj','link6_13.obj',

    [model, state, simulation, bodies, lights] = await loadSceneFromURL(mujoco, 'scene.xml', parent);

'link6_14.obj','link6_14.obj',

    camera.position.set(2, 2, -1);

'link6_15.obj','link6_15.obj',

    function animate() {

'link6_16.obj','link6_16.obj',

      requestAnimationFrame(animate);

      simulation.step();'link6_2.obj','link6_2.obj',



      controls.update();'link6_3.obj','link6_3.obj',

      renderer.render(scene, camera);

      'link6_4.obj','link6_4.obj',

      for (let a = 0; a < data[0].length; a++) {

        let k = Math.floor(i);'link6_5.obj','link6_5.obj',

        //simulation.ctrl[a] = data[k][a];

        simulation.qpos[a] = data[k][a];'link6_6.obj','link6_6.obj',

        i = (i + 0.02) % (data.length);

      }'link6_7.obj','link6_7.obj',



      simulation.forward();'link6_8.obj','link6_8.obj',



      // update world positions'link6_9.obj','link6_9.obj',

      for (let b = 0; b < model.nbody; b++) {

        if (bodies[b]) {'link6.stl','link6.stl',

          getPosition(simulation.xpos, b, bodies[b].position);

          getQuaternion(simulation.xquat, b, bodies[b].quaternion);'link7_0.obj','link7_0.obj',

          bodies[b].updateWorldMatrix();

        }'link7_1.obj','link7_1.obj',

      }

    }'link7_2.obj','link7_2.obj',



    animate();'link7_3.obj','link7_3.obj',

  </script>

</body>'link7_4.obj','link7_4.obj',



</html>'link7_5.obj','link7_5.obj',

'link7_6.obj','link7_6.obj',

'link7_7.obj','link7_7.obj',

'link7.stl','link7.stl',

'wood_tray_collision_0.obj','wood_tray_collision_0.obj',

'wood_tray_collision_1.obj','wood_tray_collision_1.obj',

'wood_tray_collision_10.obj','wood_tray_collision_10.obj',

'wood_tray_collision_11.obj','wood_tray_collision_11.obj',

'wood_tray_collision_2.obj','wood_tray_collision_2.obj',

'wood_tray_collision_3.obj','wood_tray_collision_3.obj',

'wood_tray_collision_4.obj','wood_tray_collision_4.obj',

'wood_tray_collision_5.obj','wood_tray_collision_5.obj',

'wood_tray_collision_6.obj','wood_tray_collision_6.obj',

'wood_tray_collision_7.obj','wood_tray_collision_7.obj',

'wood_tray_collision_8.obj','wood_tray_collision_8.obj',

'wood_tray_collision_9.obj','wood_tray_collision_9.obj',

'wood_tray_diffuse.png','wood_tray_diffuse.png',

'wood_tray.obj','wood_tray.obj',

    ];    ];





    const xmlText = await (await fetch(xmlURL)).text();    const xmlText = await (await fetch(xmlURL)).text();

    mujoco.FS.writeFile('/working/scene.xml', xmlText);    mujoco.FS.writeFile('/working/scene.xml', xmlText);

    console.log(xmlText);    console.log(xmlText);



    for (const meshFile of meshFiles) {    for (const meshFile of meshFiles) {

      const res = await fetch(`./static/scene/kitchen/assets/${meshFile}`);      const res = await fetch(`./static/scene/kitchen/assets/${meshFile}`);

      if (!res.ok) {      if (!res.ok) {

        console.error(`Failed to load ${meshFile}: ${res.statusText}`);        console.error(`Failed to load ${meshFile}: ${res.statusText}`);

        continue;        continue;

      }      }

      const buf = await res.arrayBuffer();      const buf = await res.arrayBuffer();

      mujoco.FS.writeFile(`/working/assets/${meshFile}`, new Uint8Array(buf));      mujoco.FS.writeFile(`/working/assets/${meshFile}`, new Uint8Array(buf));

    }    }



    async function loadData() {    async function loadData() {

      const response = await fetch('./static/data/LiftTrayEnv_BimanualPanda_2025-04-21_20-00-24.json');      const response = await fetch('./static/data/LiftTrayEnv_BimanualPanda_2025-04-21_20-00-24.json');

      const data = await response.json();      const data = await response.json();

      return data["proprioception"];      return data["proprioception"];

    }    }

    const data = await loadData();    const data = await loadData();



    // THREE.js Scene Setup    // THREE.js Scene Setup

    const scene = new THREE.Scene();    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);



    const renderer = new THREE.WebGLRenderer({ antialias: true });    const renderer = new THREE.WebGLRenderer({ antialias: true });

    renderer.setSize(window.innerWidth, window.innerHeight);    renderer.setSize(window.innerWidth, window.innerHeight);

    document.body.appendChild(renderer.domElement);    document.body.appendChild(renderer.domElement);



    const controls = new OrbitControls(camera, renderer.domElement);    const controls = new OrbitControls(camera, renderer.domElement);

    controls.enableDamping = true;    controls.enableDamping = true;



    scene.add(new THREE.AmbientLight(0x404040));    scene.add(new THREE.AmbientLight(0x404040));

    const light = new THREE.DirectionalLight(0xffffff, 1);    const light = new THREE.DirectionalLight(0xffffff, 1);

    light.position.set(4, 4, 4);    light.position.set(4, 4, 4);

    scene.add(light);    scene.add(light);



    let i = 0;    let i = 0;



    const parent = {    const parent = {

      scene: scene,      scene: scene,

      camera: camera,      camera: camera,

      controls: controls,      controls: controls,

      model: {},      model: {},

      state: {},      state: {},

      simulation: {}      simulation: {}

    };    };





    var bodies = {};    var bodies = {};

    var lights = {};    var lights = {};

    let model = parent.model;    let model = parent.model;

    let state = parent.state;    let state = parent.state;

    let simulation = parent.simulation;    let simulation = parent.simulation;



        

    [model, state, simulation, bodies, lights] = await loadSceneFromURL(mujoco, 'scene.xml', parent);    [model, state, simulation, bodies, lights] = await loadSceneFromURL(mujoco, 'scene.xml', parent);



    camera.position.set(2, 2, -1);    camera.position.set(2, 2, -1);



    function animate() {    function animate() {



      requestAnimationFrame(animate);      requestAnimationFrame(animate);

      simulation.step();      simulation.step();



      controls.update();      controls.update();

      renderer.render(scene, camera);      renderer.render(scene, camera);

            

      for (let a = 0; a < data[0].length; a++) {      for (let a = 0; a < data[0].length; a++) {

        let k = Math.floor(i);        let k = Math.floor(i);

        //simulation.ctrl[a] = data[k][a];        //simulation.ctrl[a] = data[k][a];

        simulation.qpos[a] = data[k][a];        simulation.qpos[a] = data[k][a];

        i = (i + 0.02) % (data.length);        i = (i + 0.02) % (data.length);

      }      }



      simulation.forward();      simulation.forward();



      // update world positions      // update world positions

      for (let b = 0; b < model.nbody; b++) {      for (let b = 0; b < model.nbody; b++) {

        if (bodies[b]) {        if (bodies[b]) {

          getPosition(simulation.xpos, b, bodies[b].position);          getPosition(simulation.xpos, b, bodies[b].position);

          getQuaternion(simulation.xquat, b, bodies[b].quaternion);          getQuaternion(simulation.xquat, b, bodies[b].quaternion);

          bodies[b].updateWorldMatrix();          bodies[b].updateWorldMatrix();

        }        }

      }      }

    }    }



    animate();    animate();

  </script>  </script>

</body></body>



</html></html>